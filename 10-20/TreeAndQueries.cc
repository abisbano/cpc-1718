/*
 TreeAndQueries.cc
 Author: Andrea Bisbano
 Date: 14/01/18
 Problem: http://codeforces.com/contest/375/problem/D
 Solution:
  This algorithm performs a DFS visit of the input tree to generate the euler tour of that
  tree. While doing the visit it generates an array A, where A[i] is the color of the vertex
  i of the Euler's tour generated by the DFS. Each query is transformed in a range query
  using the start and finish time of the vertex queried.
  Then the queries are divided in sqrt(n) buckets and sorted according to Mo's algorithm.
  To reply to each query the algorithm keeps two support array: the first one contains
  the number of occurrences of each color and the second one contains for each index i
  the number of colors that appears at least i times.
  The update operation takes O(1) time and also the reply (they're update and access to
  those arrays).
 Time cost: O((n+m)sqrt(n)) where n is the number of vertices and m number of queries.
 Space cost: O(n) because the support arrays can't exceed the size of input tree.
*/

#include <iostream>
#include <cassert>
#include <vector>
#include <algorithm>
#include <cmath>

struct Query {
  size_t l, r, k, id;
};

struct Tree {
  std::vector<int> colors;
  std::vector<std::vector<int>> edges;
  std::vector<size_t> start;
  std::vector<size_t> finish;

  Tree(size_t size) {
    colors.reserve(size);
    edges.resize(size);
    start.assign(size, 0);
    finish.assign(size, 0);
  }

  void startDfs(std::vector<int> &arr) {
    dfs(arr, 0, -1);
  }

private:

  void dfs(std::vector<int> &arr, size_t v, size_t dad) {
    arr.push_back(colors[v]);
    start[v] = arr.size() - 1;
    for (auto w : edges[v]) {
      if (w == dad) continue;
      dfs(arr, w, v);
    }
    finish[v] = arr.size() - 1;
  }
};

struct Counter {

  std::vector<int> count;
  std::vector<int> solutions;

  Counter(const int maxColor) {
    count.assign(1+maxColor, 0);
    solutions.push_back(maxColor); // dummy solution for k = 0;
  }

  void add(const int color) {
    ++count[color];
    if (count[color] >= solutions.size()) solutions.push_back(0);
    ++solutions[count[color]];
  }

  void remove(const int color) {
    --solutions[count[color]];
    --count[color];
    if (solutions.back() == 0) solutions.pop_back();
  }

  int answer(const int k) const {
    return k < solutions.size() ? solutions[k] : 0;
  }
};

int main() {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(NULL);

  size_t nVert, nQueries;
  int c;
  size_t a, b;
  size_t v, k;
  std::vector<Query> queries;

  std::cin >> nVert >> nQueries;
  assert(nVert <= 100000);
  assert(nQueries <= 100000);

  Tree t(nVert);

  for (size_t i = 0; i < nVert; ++i) {
    std::cin >> c;
    t.colors.push_back(c);
  }

  for (size_t i = 0; i < nVert-1; ++i) {
    std::cin >> a >> b;
    --a; --b;
    t.edges[a].push_back(b);
    t.edges[b].push_back(a);
  }

  std::vector<int> arr;
  arr.reserve(nVert);
  t.startDfs(arr);

  for (size_t i = 0; i < nQueries; ++i) {
    std::cin >> v >> k;
    --v;
    queries.push_back(Query{t.start[v], t.finish[v], k, i});
  }

  std::vector<int> result(nQueries);

  // Mo algorithm

  size_t buckets = (size_t) sqrt(nVert) + 1;

  std::sort(queries.begin(), queries.end(), [buckets] (const Query &a, const Query &b) {
    if (a.l/buckets != b.l/buckets) {
      return a.l/buckets < b.l/buckets;
    }
    return a.r < b.r;
  });

  Counter counter(*std::max_element(t.colors.begin(), t.colors.end()));

  int currL = 0, currR = -1;
  for (auto q : queries) {
    while (currR < (int) q.r) {
      counter.add(arr[++currR]);
    }
    while (currL < (int) q.l) {
      counter.remove(arr[currL++]);
    }
    while (currL > (int) q.l) {
      counter.add(arr[--currL]);
    }
    while (currR > (int) q.r) {
      counter.remove(arr[currR--]);
    }
    result[q.id] = counter.answer(q.k);
  }

  for (auto i : result) {
    std::cout << i << "\n";
  }

  return 0;
}
